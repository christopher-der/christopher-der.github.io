---
layout: post
title:  "Blog 5"
date:   2020-10-06 12:01:00 -0700
categories: jekyll update
---
<h1><b>Cracking Unix/Linux Passwords Using a Password File Code Analysis (Bruteforce)</b></h1>

<h2><b>Introduction:</b></h2>
<p>In this blog, I would be doing something a little different than I would normally do. This is somewhat a combination between a tutorial and analysis for a code I have created for cracking UNIX/Linux passwords while given a password file for me to bruteforce. For those who do not know, when you create a username and password on a Linux OS, the information regarding the user you have created will be stored in the etc/shadow file. However, the Linux OS does not save your plaintext password because it would become a security issue if someone were to access or intrude into your files. Instead, it encrypts the password in a one way function called hashing with another piece of data called salt. When you hash data, it would generate a random output that you can use to identify whether the data has its integrity intact. The hash cannot be reverted back to its original data and changing/altering the data will also alter the hash if you hash the data again; therefore, its the best way to maintain and check data integrity. Together, it will create an unique identifier that the Linux OS can match with the password you enter when you login each time by hashing the password you just enter. If both of those hashes match, then you are able to login. In this blog, I will go over the code/algorithm that I created and used to show how the entire process works by using a password file that contains 100,000 password to crack a user's account. I used Python 3.8.5 to create this script and I will split the explanation and analysis into multiple parts so you guys can understand what is going on in the code without getting overwhelmed with the amount of information and logic I used going about it. </p>

<h2><b>Requirements:</b></h2>
<ul>
    <li>Linux OS (can use VM)</li>
    <li>/etc/shadow file </li>
    <li>Password file</li>
    <li>Visual Studio Code (must have Python installed)</li>
    <li>Password Cracking Code/Algorithm</li>
</ul>
<h2><b>The Process:</b></h2>
<img src="https://i.gyazo.com/26a48f91d8ed00ce6efc9d7e7dae6947.png">
<p>In this picture, we're setting up some variables and arrays before we begin the process of itterating through multiple for-loops. As we can see here, in line 1, we are using the import command to import the crypt module into the program. This command will allow us to use the crypt.crypt function to combine the salt and the plaintext password into a hash. I will explain more about the crypt.crypt function when we get to it in the code. Lines 3 and 4 allows the program to read through each file line by line and stores them into array. Lines 5 to 9 is setting up my variables to gather the number of users and passwords from both of the length of arrays in preparation for the for-loop.
</p>

<img src="https://i.gyazo.com/b5517f8a3aac0da6b6240b3c4c8758a4.png">
<p>Okay so this is where the fun begins! In my mind, I was thinking about itterating each user through thousands of passwords to check if the hashes match. This idea reminds me of how multiplication works where lets say we have a x b, where a is the user and b is the password. I would start off as the first user (a=1) and start off with the first password (b=1). If the first password doesn't match, then I'll move on to the next one, and to the next, and etc. In math, it would basically look like this: 1x1, 1x2, 1x3, 1x4, etc. To apply this concept into coding, I decided that it would be in my best interest to do a nested for-loop where the outer for-loop will itterate through each user and the inner for-loop will itterate through each password. Because I'm itterating through each user once, I decided that my outter for-loop will fulfill that role since I would have no use of itterating through the same user again if I already cracked his or her password. However before I am able to itterate through each user, I have to set the entire process up. Line 13-17 of the code basically grabs the data of each users and assigns it to a variable. Notice in line 3 of the code, it stores each line in each element of the array. I have to loop through each element of the array and extract that string from it. Doing so, would leave me with the entirety of each individual user data. What I notice here is that the username, the hash function, and other miscellaneous information are separated by &quot;:&quot;. As a result, I decided to use the split function to create another array in which each element contains part of the string (not including &quot;:&quot;). Now, I know that the my userdata is an array that contains username in element 0 and the hash in element 1. As you can see in lines 15-16, I extracted those strings from the elements and assign them to a variable. However, I still need my salt and I noticed that the salt is 12 characters long across all usernames who has an encrypted password. In line 17, I grabed the first 12 letters of the string and assigned them to a variable called salt. The code in Line 19-20 is not necessary, but it speeds the process expoentially. Because we have 40 users and 100,000 passwords, it means the program will have to itterate to at most 4,000,000 passwords for it to finish which will take a substantial amount of time. To minimize the wait time and to increase the efficiency of the program, line 19-20 skips users who do not have an encrypted password.
</p>

<img src="https://i.gyazo.com/ed94fe4c2b569d471d940f5d67215aca.png">
<p>Back in line 4 of the code, I stored each password into different elements of the array. Because I am going to cycle through each password, I need to take the 0 element of my array that contains the password and extract that string out for me to assign to a variable. The problem now is that each password has a &quot;\n&quot; character at the end of every line to indicate a new line has been made. In line 24, I reassigned the same variable to take all the characters from the string minus the last character which is the &quot;\n&quot;. That way, when the program loops through the 100,000 plaintext passwords and inserts them into my crypt.crypt function, it will eventually yield the correct hash for me to crack the user. The rest of the code is pretty much straight forward. The crypt.crypt module or function takes in two arguments: plaintext(the password) and the salt. The output will yield a hash from the crypt module will be stored into a variable as a string called substring. The program will then compare it to the hash stored in the &quot;passwd&quot;. If it matches, then the program breaks out of the inner for-loop, prints out the username and password, and proceeds onto the next user.
</p>
<p>Well, I hope you guys like the explanation of my code about the logic behind cracking UNIX/LINUX OS passwords. There are other variations or logical algorithms go about it, but this is my way of the approach. It's simple, clean, and efficient. I hope all of you learn something today and hope that you guys can try this little project for yourself. That's it for now and I'll see you guys next week with another new blog!
</p>